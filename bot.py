import os
import asyncio
import time
import random
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes

# ---- 🟢 FAKE PORT SERVER (Keeps Render Awake) ----
class SimpleHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        self.wfile.write(b"Bot is alive!")

def run_server():
    port = int(os.environ.get("PORT", 10000))
    server = HTTPServer(("0.0.0.0", port), SimpleHandler)
    server.serve_forever()

threading.Thread(target=run_server, daemon=True).start()
# --------------------------------------------------

BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID"))  # Put your Telegram user ID here or in env

app = ApplicationBuilder().token(BOT_TOKEN).build()

# ---- GLOBALS ----
players = {}  # username -> {phone, chat_id, taps, first5}
round_active = False
start_time = None
active_codes = []  # one-time codes generated by admin
current_round_players = []  # usernames in current round
pending_payout = None  # {username, phone, taps, expires}

# ---- PLAYER COMMANDS ----
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "⚠️ Disclaimer: Only stake money you are ready to lose.\n\n"
        "To participate, register your phone with /register 07XXXXXXXX\n"
        "Then wait for admin to give you a one-time game code."
    )
    await update.message.reply_text(text)

async def register(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if len(context.args) != 1:
        await update.message.reply_text("Use: /register 07XXXXXXXX")
        return

    phone = context.args[0]
    username = update.effective_user.username
    chat_id = update.effective_chat.id
    players[username] = {"phone": phone, "chat_id": chat_id, "taps": 0, "first5": 0}
    await update.message.reply_text(f"✅ Registered @{username} ({phone})")

async def entergame(update: Update, context: ContextTypes.DEFAULT_TYPE):
    username = update.effective_user.username
    if username not in players:
        await update.message.reply_text("❌ You must register first with /register.")
        return

    await update.message.reply_text("Enter your one-time game code:")
    context.user_data['awaiting_code'] = True

async def handle_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    username = update.effective_user.username
    if not context.user_data.get('awaiting_code'):
        return

    code = update.message.text.strip()
    if code not in active_codes:
        await update.message.reply_text("❌ Invalid code.")
        return

    # Code valid
    active_codes.remove(code)
    current_round_players.append(username)
    context.user_data['awaiting_code'] = False
    await update.message.reply_text("✅ You are in! Waiting for other players…")

    # Start countdown if 10 players joined
    if len(current_round_players) == 10:
        await start_countdown_for_round(context)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "/register 07XXXXXXXX — register with your phone\n"
        "/entergame — enter game with one-time code\n"
        "/help — show this help message\n"
        "Rules:\n"
        "- Deposit first and send proof to admin\n"
        "- Only 10 players per round\n"
        "- Tap as fast as possible in DM for 10 seconds\n"
        "- Tie-breaker: most taps in first 5 seconds\n"
        "- Winner must send /claim within 3 minutes to get payout"
    )
    await update.message.reply_text(text)

async def claim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global pending_payout
    username = update.effective_user.username
    if not pending_payout:
        await update.message.reply_text("No pending payout at the moment.")
        return

    if username != pending_payout["username"]:
        await update.message.reply_text("You are not the pending winner.")
        return

    # Successful claim
    await context.bot.send_message(
        ADMIN_ID,
        f"✅ Payout claim by @{username}\nPhone: {pending_payout['phone']}\nTaps: {pending_payout['taps']}"
    )
    await update.message.reply_text("✅ Claim received. Admin notified for payout.")
    pending_payout = None

# ---- ADMIN COMMANDS ----
async def generate_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("❌ Only admin can generate codes.")
        return

    num = random.randint(100, 999)
    code = f"TTW{num}"
    active_codes.append(code)
    await update.message.reply_text(f"✅ Code generated: {code}")

# ---- ROUND / TAP LOGIC ----
async def start_countdown_for_round(context):
    global round_active, start_time
    round_active = True
    start_time = None
    # DM countdown to all 10 players
    for i in range(5, 0, -1):
        for u in current_round_players:
            try:
                await context.bot.send_message(players[u]["chat_id"], f"Game starting in {i}...")
            except Exception:
                pass
        await asyncio.sleep(1)

    # Start tapping
    start_time = time.time()
    for u in current_round_players:
        try:
            button = InlineKeyboardButton("👆 TAP", callback_data="tap")
            markup = InlineKeyboardMarkup([[button]])
            await context.bot.send_message(players[u]["chat_id"], "🚀 Start tapping! 10 seconds go!", reply_markup=markup)
        except Exception:
            pass

    await asyncio.sleep(10)
    round_active = False

    # Stop message
    for u in current_round_players:
        try:
            await context.bot.send_message(players[u]["chat_id"], "⏱ Time’s up!")
        except Exception:
            pass

    # Compute winner
    highest = max(players[u]["taps"] for u in current_round_players)
    tied = [u for u in current_round_players if players[u]["taps"] == highest]
    if len(tied) == 1:
        winner = tied[0]
    else:
        winner = min(tied, key=lambda u: players[u]["first5"])

    w_phone = players[winner]["phone"]
    w_taps = players[winner]["taps"]

    # Leaderboard for group
    result = "\n".join([f"@{u}: {players[u]['taps']} taps" for u in current_round_players])
    for u in current_round_players:
        # Reset taps for next round
        players[u]["taps"] = 0
        players[u]["first5"] = 0
    current_round_players.clear()

    group_chat_id = ADMIN_ID  # Replace with actual group chat ID if you want
    await context.bot.send_message(group_chat_id, f"🏆 Winner: @{winner}\n📊 Results:\n{result}")
    await context.bot.send_message(group_chat_id, "Waiting for next round players…")

    # Set pending payout
    global pending_payout
    pending_payout = {"username": winner, "phone": w_phone, "taps": w_taps, "expires": time.time() + 180}
    try:
        await context.bot.send_message(players[winner]["chat_id"],
                                       "🎉 You won! Send /claim within 3 minutes to confirm your payout.")
    except Exception:
        pass

    # Start task to auto-expire pending payout
    asyncio.create_task(expire_pending_payout(context))

async def expire_pending_payout(context):
    global pending_payout
    if not pending_payout:
        return
    while True:
        await asyncio.sleep(5)
        if pending_payout and time.time() > pending_payout["expires"]:
            try:
                await context.bot.send_message(players[pending_payout["username"]]["chat_id"],
                                               "⏰ 3 minutes expired. You lost the prize.")
            except Exception:
                pass
            pending_payout = None
            break

async def tap(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global start_time
    if not round_active or start_time is None:
        await update.callback_query.answer("Round not active!", show_alert=True)
        return

    username = update.effective_user.username
    if username not in players:
        await update.callback_query.answer("You must register first with /register", show_alert=True)
        return

    elapsed = time.time() - start_time
    players[username]["taps"] += 1
    if elapsed <= 5:
        players[username]["first5"] = elapsed
    await update.callback_query.answer(f"Tap count: {players[username]['taps']}")

# ---- HANDLERS ----
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("register", register))
app.add_handler(CommandHandler("entergame", entergame))
app.add_handler(CommandHandler("help", help_command))
app.add_handler(CommandHandler("claim", claim))
app.add_handler(CommandHandler("codezadeh312", generate_code))
app.add_handler(CallbackQueryHandler(tap, pattern="^tap$"))
app.add_handler(MessageHandler(lambda u, c: True, handle_code))  # catches all messages for code input

if __name__ == "__main__":
    app.run_polling()
